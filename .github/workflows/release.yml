name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g. v0.1.0)'
        required: true
        default: 'v0.1.0'

# Add permissions block for GITHUB_TOKEN
permissions:
  contents: write
  discussions: write

env:
  CARGO_TERM_COLOR: always

jobs:
  create_release:
    name: Create Release
    # Only run when a tag is pushed or on manual workflow dispatch
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    
    steps:
    - name: Get version
      id: get_version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          # Remove refs/tags/ prefix
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi
    
    - name: Validate version format
      run: |
        VERSION="${{ steps.get_version.outputs.version }}"
        
        # Check if version starts with v and followed by numbers and dots
        if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
          echo "::error::Invalid version format: $VERSION. Version must start with 'v' followed by semantic version (e.g. v1.2.3)"
          exit 1
        fi
        
        echo "Version format is valid: $VERSION"
    
    - name: Create Release
      id: create_release
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { data: release } = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: '${{ steps.get_version.outputs.version }}',
            name: 'Release ${{ steps.get_version.outputs.version }}',
            draft: true,
            prerelease: false,
            body: `## RCP ${{ steps.get_version.outputs.version }}
            
            Please refer to [CHANGELOG.md](https://github.com/open-rcp/rcp/blob/main/CHANGELOG.md) for detailed changes.
            
            ### Downloads
            
            Each package includes the binary and necessary configuration files.
            
            #### Windows
            - \`rcpp-windows.zip\` (RCP Protocol)
            - \`rcpc-windows.zip\` (RCP Client)
            - \`rcpd-windows.zip\` (RCP Daemon)
            
            #### Linux
            - \`rcpp-linux.tar.gz\` (RCP Protocol)
            - \`rcpc-linux.tar.gz\` (RCP Client)
            - \`rcpd-linux.tar.gz\` (RCP Daemon)
            
            #### macOS
            - \`rcpp-macos.tar.gz\` (RCP Protocol)
            - \`rcpc-macos.tar.gz\` (RCP Client)
            - \`rcpd-macos.tar.gz\` (RCP Daemon)`
          });
          
          core.setOutput('upload_url', release.upload_url);
          return release;

  build:
    name: Build for ${{ matrix.os }}
    needs: create_release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            target: x86_64-unknown-linux-gnu
            archive_ext: tar.gz
            archive_cmd: tar -czf
          - os: windows-latest
            platform: windows
            target: x86_64-pc-windows-msvc
            archive_ext: zip
            archive_cmd: zip -r
          - os: macos-latest
            platform: macos
            target: x86_64-apple-darwin
            archive_ext: tar.gz
            archive_cmd: tar -czf
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        target: ${{ matrix.target }}
    
    - name: Rust cache
      uses: swatinem/rust-cache@v2
      with:
        shared-key: "build-${{ matrix.target }}"
    
    - name: Install dependencies for Linux
      if: matrix.platform == 'linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev pkg-config zip unzip
    
    - name: Run Clippy
      run: cargo clippy --all-targets --all-features -- -D warnings
    
    - name: Build RCP Protocol
      run: cargo build --release --package rcpp --target ${{ matrix.target }}
    
    - name: Build RCP Client
      run: cargo build --release --package rcpc --target ${{ matrix.target }}
    
    - name: Build RCP Daemon
      run: cargo build --release --package rcpd --target ${{ matrix.target }}
    
    # Protocol package preparation
    - name: Create Protocol Package Directory
      run: mkdir -p rcpp-pkg
      shell: bash
    
    - name: Copy Protocol Binary (Windows)
      if: matrix.platform == 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpp.exe rcpp-pkg/rcpp.exe
        cp config.toml rcpp-pkg/config.toml
      shell: bash
    
    - name: Copy Protocol Binary (Linux/macOS)
      if: matrix.platform != 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpp rcpp-pkg/rcpp
        cp config.toml rcpp-pkg/config.toml
      shell: bash
    
    - name: Package Protocol (Windows)
      if: matrix.platform == 'windows'
      run: Compress-Archive -Path rcpp-pkg/* -DestinationPath rcpp-windows.zip
      shell: pwsh
    
    - name: Package Protocol (Linux/macOS)
      if: matrix.platform != 'windows'
      run: tar -czf rcpp-${{ matrix.platform }}.${{ matrix.archive_ext }} -C rcpp-pkg .
      shell: bash
    
    # Client package preparation
    - name: Create Client Package Directory
      run: mkdir -p rcpc-pkg
      shell: bash
    
    - name: Copy Client Binary (Windows)
      if: matrix.platform == 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpc.exe rcpc-pkg/rcpc.exe
      shell: bash
    
    - name: Copy Client Binary (Linux/macOS)
      if: matrix.platform != 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpc rcpc-pkg/rcpc
      shell: bash
    
    - name: Package Client (Windows)
      if: matrix.platform == 'windows'
      run: Compress-Archive -Path rcpc-pkg/* -DestinationPath rcpc-windows.zip
      shell: pwsh
    
    - name: Package Client (Linux/macOS)
      if: matrix.platform != 'windows'
      run: tar -czf rcpc-${{ matrix.platform }}.${{ matrix.archive_ext }} -C rcpc-pkg .
      shell: bash
    
    # Daemon package preparation
    - name: Create Daemon Package Directory
      run: mkdir -p rcpd-pkg
      shell: bash
    
    - name: Copy Daemon Binary (Windows)
      if: matrix.platform == 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpd.exe rcpd-pkg/rcpd.exe
        cp config.toml rcpd-pkg/config.toml
      shell: bash
    
    - name: Copy Daemon Binary (Linux/macOS)
      if: matrix.platform != 'windows'
      run: |
        cp target/${{ matrix.target }}/release/rcpd rcpd-pkg/rcpd
        cp config.toml rcpd-pkg/config.toml
      shell: bash
    
    - name: Package Daemon (Windows)
      if: matrix.platform == 'windows'
      run: Compress-Archive -Path rcpd-pkg/* -DestinationPath rcpd-windows.zip
      shell: pwsh
    
    - name: Package Daemon (Linux/macOS)
      if: matrix.platform != 'windows'
      run: tar -czf rcpd-${{ matrix.platform }}.${{ matrix.archive_ext }} -C rcpd-pkg .
      shell: bash
    
    # Upload assets
    - name: Upload Release Assets
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Define the asset files based on platform
          const platform = '${{ matrix.platform }}';
          const ext = platform === 'windows' ? 'zip' : 'tar.gz';
          const contentType = platform === 'windows' ? 'application/zip' : 'application/gzip';
          
          // Assets to upload
          const assets = [
            { name: `rcpp-${platform}.${ext}`, path: `./rcpp-${platform}.${ext}` },
            { name: `rcpc-${platform}.${ext}`, path: `./rcpc-${platform}.${ext}` },
            { name: `rcpd-${platform}.${ext}`, path: `./rcpd-${platform}.${ext}` }
          ];
          
          // Get release by tag
          const { data: releases } = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo
          });
          
          const release = releases.find(r => r.tag_name === '${{ needs.create_release.outputs.version }}');
          
          if (!release) {
            core.setFailed(`No release found with tag: ${{ needs.create_release.outputs.version }}`);
            return;
          }
          
          // Upload each asset
          for (const asset of assets) {
            console.log(`Uploading ${asset.name}...`);
            
            try {
              // Read file as binary
              const fileContent = fs.readFileSync(asset.path);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                name: asset.name,
                data: fileContent,
                headers: {
                  'content-type': contentType,
                  'content-length': fs.statSync(asset.path).size
                }
              });
              
              console.log(`Successfully uploaded ${asset.name}`);
            } catch (error) {
              console.error(`Failed to upload ${asset.name}: ${error.message}`);
              core.warning(`Failed to upload ${asset.name}: ${error.message}`);
            }
          }

  publish:
    name: Publish Release
    needs: [create_release, build]
    runs-on: ubuntu-latest
    if: ${{ !failure() && !cancelled() }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      
      - name: Publish to crates.io
        run: |
          echo "Skipping crates.io publication by default"
          echo "To publish to crates.io, uncomment the publication step in the workflow file"
          
          # Uncomment the following section to enable crates.io publishing
          # if [ -n "${{ secrets.CRATES_IO_TOKEN }}" ]; then
          #   echo "Publishing to crates.io..."
          #   cargo login ${{ secrets.CRATES_IO_TOKEN }}
          #   
          #   # Try to publish each crate, but continue on error
          #   cd rcpp && cargo publish --allow-dirty || echo "Failed to publish rcpp, it may already exist"
          #   
          #   # Wait a bit for crates.io to index
          #   sleep 30
          #   
          #   cd ../rcpc && cargo publish --allow-dirty || echo "Failed to publish rcpc, it may already exist"
          #   cd ../rcpd && cargo publish --allow-dirty || echo "Failed to publish rcpd, it may already exist"
          # else
          #   echo "CRATES_IO_TOKEN is not set. Skipping publish to crates.io."
          #   echo "To publish to crates.io, add a repository secret named CRATES_IO_TOKEN"
        if: ${{ false }}  # This line ensures this step is always skipped
      
      - name: Finalize GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // For workflow_dispatch events, use the specified version
            // For tag events, extract the tag name from GITHUB_REF
            let versionTag = '${{ needs.create_release.outputs.version }}';
            
            // Make sure the version tag doesn't include 'refs/tags/' prefix
            if (versionTag.startsWith('refs/tags/')) {
              versionTag = versionTag.replace('refs/tags/', '');
            }
            
            console.log(`Looking for draft release with tag: ${versionTag}`);
            
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 10
            });
            
            // Find the draft release with matching tag
            const draftRelease = releases.find(release => 
              release.draft === true && 
              release.tag_name === versionTag
            );
            
            if (draftRelease) {
              console.log(`Finalizing release id: ${draftRelease.id}`);
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: draftRelease.id,
                draft: false
              });
              console.log(`Successfully finalized release: ${versionTag}`);
            } else {
              console.log(`No matching draft release found for tag: ${versionTag}`);
              console.log('Available releases:');
              releases.forEach(release => {
                console.log(`- ${release.tag_name} (Draft: ${release.draft})`);
              });
            }